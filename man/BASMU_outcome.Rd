% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{BASMU_outcome}
\alias{BASMU_outcome}
\title{Scalar on image regression with unmeasured confounder}
\usage{
BASMU_outcome(
  Y,
  M,
  X,
  C,
  L_all,
  eta,
  delta_sp,
  num_region,
  region_idx,
  n_mcmc,
  K,
  stop_burnin,
  target_accept_vec,
  a,
  b,
  init,
  step,
  interval_step,
  interval_thin,
  start_joint = 0L,
  lambda = 0,
  residual_update = FALSE
)
}
\arguments{
\item{Y}{The scalar outcome variable, n by 1}

\item{M}{The image predictor, p by n}

\item{X}{The scalar exposure variable, n by 1}

\item{C}{The q confounders, n by q}

\item{L_all}{A vector of length num_region, each element is an integer to indicate the number of basis in each region}

\item{eta}{A matrix of size p by n, the latent confounder}

\item{delta_sp}{A p-by-1 indicator vector to specify the non-zero elements in nu, initial value for delta_nu}

\item{num_region}{An integer, the total number of regions}

\item{region_idx}{A list object of length num_region, each element is a vector of
the indices of each voxel in that region. Note that this index starts from 0.}

\item{n_mcmc}{An integer to indicate the total number of MCMC iterations}

\item{K}{A list object of length num_region, the r-th element is a p_r by L_r matrix for the basis function}

\item{stop_burnin}{An integer to indicate from which iteration to stop burnin period.
Note that during burinin, the step size in MALA is adjusted every interval_step iterations.}

\item{target_accept_vec}{A vector of length num_region. Each element is a numeric variable in (0,1).
This allows the user to define different target acceptance rate for each region in the MALA algorithm,
and the step size will be adjusted to meet the target acceptance rate.}

\item{a}{A numeric variable for the Inverse-Gamma(a,b), priors for \eqn{\sigma^2_Y,\sigma^2_\beta}}

\item{b}{A numeric variable for the Inverse-Gamma(a,b), priors for \eqn{\sigma^2_Y,\sigma^2_\beta}}

\item{init}{A list object that contains the following element
\itemize{
  \item theta_beta A vector of length L. Initial value for theta_beta
  \item gamma A numeric scalar, initial value for gamma
  \item zetay A vector of length q, intial value for zetay
  \item sigma_Y A numeric scalar, initial value for sigma_Y
  \item sigma_beta A numeric scalar, initial value for sigma_beta
  \item nu A vector of length p, initial value for nu
  \item cb A numeric scalar, initial value for cy (=0)
  \item D A vector of length L. Eigenvalues for all regions in the basis
}}

\item{step}{A numeric vector of length num_region, the initial step size for each region}

\item{interval_step}{An integer to denote how often to update the step size}

\item{interval_thin}{An integer to denote how often to save the MCMC samples for theta_alpha}

\item{start_joint}{An integer to indicate from which iteration to start updating parameters other than beta. Default = 0.}

\item{lambda}{A numeric variable to indicate the thresholding parameter lambda in STGP prior. Default = 0.}
}
\value{
A List object with the following component
\itemize{
\item theta_alpha_mcmc
\item logll_mcmc
\item track_step
\item accept_block
\item emp_accept
\item gs A list object with the following component
  \itemize{
    \item theta_zetam_mcmc
    \item sigma_M2_inv_mcmc
    \item sigma_alpha2_inv_mcmc
    \item sigma_eta2_inv_mcmc
  }
\item Timer
}
}
\description{
{A basis decomposition is used. The main coefficient beta follows STGP prior.
Kernel matrices need to be pre-speficified}
}
